<!DOCTYPE html>
<html><head><style>
    body {
        margin: 0;
    }
</style></head><body>
<canvas id="canvas" width="1160px" height="580px"></canvas>
<script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const blockSide = 36;
    const margin = 4;
    const dungeonPieceAssetPathPat = /^Adventure\/Dungeon\/Piece\/PartsCity10\/(DungeonParts(?:_2x1)?_[^_]+)(?:_(\d+))?$/;
    const moveDist = 20;

    const clearBackground = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    };

    const drawEntrance = (startx, starty, block) => {
        ctx.strokeStyle = "#FF00FF";

        if (block.top === 1) {
            ctx.beginPath();
            ctx.moveTo(startx, starty);
            ctx.lineTo(startx + blockSide, starty);
            ctx.stroke();
        }

        if (block.right === 1) {
            ctx.beginPath();
            ctx.moveTo(startx + blockSide, starty);
            ctx.lineTo(startx + blockSide, starty + blockSide);
            ctx.stroke();
        }

        if (block.bottom === 1) {
            ctx.beginPath();
            ctx.moveTo(startx, starty + blockSide);
            ctx.lineTo(startx + blockSide, starty + blockSide);
            ctx.stroke();
        }

        if (block.left === 1) {
            ctx.beginPath();
            ctx.moveTo(startx, starty);
            ctx.lineTo(startx, starty + blockSide);
            ctx.stroke();
        }
    }

    const drawDungeonPart = (i, x, y, dungeonPart, backgroundColor) => {
        dungeonPart.forEach((block) => {
            const startx = x + block.x*(blockSide+margin);
            const starty = y + block.y*(blockSide+margin);
            if (backgroundColor === undefined) {
                backgroundColor = "#FFFFFF";
            }
            ctx.strokeStyle = "#FFFFFF";
            ctx.strokeRect(startx, starty, blockSide, blockSide);

            const padding = 2;
            ctx.fillStyle = backgroundColor;
            ctx.font = blockSide.toString() + "px serif"
            const textx = startx + padding;
            const texty = y + block.y*(blockSide+margin) + blockSide - padding;
            ctx.fillText(i.toString(), textx, texty, blockSide);
        });

        dungeonPart.forEach((block) => {
            const startx = x + block.x*(blockSide+margin);
            const starty = y + block.y*(blockSide+margin);
            drawEntrance(startx, starty, block);
        });
    };

    const dungeonParts = {
        DungeonParts_Start: [{x: 0, y: 0, top: 1, right: 0, bottom: 0, left: 0}],
        DungeonParts_Boss: [{x: 0, y: 0, top: 0, right: 0, bottom: 1, left: 0}],
        DungeonParts_CurveL01: [{x: 0, y: 0, top: 1, right: 1, bottom: 0, left: 0}],
        DungeonParts_Straight01: [{x: 0, y: 0, top: 1, right: 0, bottom: 1, left: 0}],
        DungeonParts_Straight02: [{x: 0, y: 0, top: 1, right: 0, bottom: 1, left: 0}],
        DungeonParts_Straight03: [{x: 0, y: 0, top: 1, right: 0, bottom: 1, left: 0}],
        DungeonParts_Straight04: [{x: 0, y: 0, top: 1, right: 0, bottom: 1, left: 0}],
        DungeonParts_Straight05: [{x: 0, y: 0, top: 1, right: 0, bottom: 1, left: 0}],
        DungeonParts_2x1_CurveL01: [
            {x: 0, y: 0, top: 1, right: 1, bottom: 0, left: 0},
            {x: 1, y: 0, top: 0, right: 1, bottom: 0, left: 1}
        ],
        DungeonParts_2x1_CurveReverseL01: [
            {x: 0, y: 0, top: 0, right: 1, bottom: 0, left: 1},
            {x: 1, y: 0, top: 1, right: 0, bottom: 0, left: 1}
        ],
        DungeonParts_2x1_CurveReverseL02: [
            {x: 0, y: 0, top: 0, right: 1, bottom: 0, left: 1},
            {x: 1, y: 0, top: 1, right: 0, bottom: 0, left: 1}
        ],
        DungeonParts_2x1_CurveS01: [
            {x: 0, y: 0, top: 1, right: 1, bottom: 0, left: 0},
            {x: 1, y: 0, top: 0, right: 0, bottom: 1, left: 1}
        ],
        DungeonParts_2x1_CurveReverseS01: [
            {x: 0, y: 0, top: 0, right: 1, bottom: 1, left: 0},
            {x: 1, y: 0, top: 1, right: 0, bottom: 0, left: 1}
        ],
        DungeonParts_2x1_CurveU01: [
            {x: 0, y: 0, top: 1, right: 1, bottom: 0, left: 0},
            {x: 1, y: 0, top: 1, right: 0, bottom: 0, left: 1}
        ],
        DungeonParts_2x1_Straight02: [
            {x: 0, y: 0, top: 0, right: 1, bottom: 0, left: 1},
            {x: 1, y: 0, top: 0, right: 1, bottom: 0, left: 1}
        ],
    };

    /* dungeonPart rotates counterclockwise but the entrances clockwise */
    const rotateDungeonPart = (dungeonPart, angle) => {
        if (angle == 90) {
            const result = new Array();
            for (const block of dungeonPart) {
                result.push({
                    x: -(block.y),
                    y: block.x,
                    top: block.left,
                    right: block.top,
                    bottom: block.right,
                    left: block.bottom,
                })
            }
            return result;
        }

        let result = dungeonPart;

        for (let i = 0; i < angle/90; ++i) {
            result = rotateDungeonPart(result, 90);
        }

        return result;
    };

    const getJson = async (url) => {
        const res = await fetch(url);
        return res.json();
    };

    const splitAssetPath = (assetPath) => {
        const match = assetPath.match(dungeonPieceAssetPathPat);
        return (match !== null) ? {name: match[1], angle: (match[2] !== undefined ? +match[2] : null)} : null;
    };

    const dungeonPieceIdToAssetName = (dungeonPieceId, dungeonPiecesMasterData) => {
        for (const dungeonPiece of dungeonPiecesMasterData) {
            if (dungeonPiece.id === dungeonPieceId) {
                return splitAssetPath(dungeonPiece.asset_path);
            }
        }
        return null;
    };

    const drawDungeonPieces = (x, y, dungeonPieces, dungeonPiecesMasterData) => {
        let i = 0;
        for (const dungeonPiece of dungeonPieces) {
            let asset = dungeonPieceIdToAssetName(dungeonPiece.dungeonPieceId, dungeonPiecesMasterData);
            let dungeonPart = dungeonParts[asset.name];

            if (dungeonPart) {
                const dungeonPieceX = (dungeonPiece.x ? dungeonPiece.x : 0);
                const dungeonPieceY = (dungeonPiece.y ? dungeonPiece.y : 0);
                const dungeonPartX = x + dungeonPieceX*(blockSide + margin);
                const dungeonPartY = y + dungeonPieceY*(blockSide + margin);

                if (asset.angle !== null) {
                    dungeonPart = rotateDungeonPart(dungeonPart, asset.angle);
                }

                let backgroundColor = "#FFFFFF";
                if (asset.name == "DungeonParts_Start") {
                    backgroundColor = "#FF0000";
                } else if (asset.name == "DungeonParts_Boss") {
                    backgroundColor = "#00FF00";
                }

                drawDungeonPart(i, dungeonPartX, dungeonPartY, dungeonPart, backgroundColor);
            } else {
                console.log("WARNING: " + asset.name + " not found in dungeonParts!!!");
            }

            i += 1;
        }
    }

    const nonVisitedNode = "N";
    const visitedNode = "V";
    const objectiveNode = "O"

    const createGrid = (gridWidth, gridHeight) => {
        const grid = [];
        for (let y = 0; y < gridHeight; ++y) {
            grid[y] = [];
            for (let x = 0; x < gridWidth; ++x) {
                grid[y][x] = nonVisitedNode
            }
        }
        return grid;
    };

    const getNeighbourPositions = (x, y) => {
        return [
            [x - 1, y],
            [x + 1, y],
            [x, y + 1],
            [x, y - 1],
        ];
    };

    const getPossibleNextPositions = (x, y, grid) => {
        const result = new Array();

        for (const [neightbourX, neightbourY] of getNeighbourPositions(x, y)) {
            let row = grid[neightbourY];
            if (row !== undefined) {
                const node = row[neightbourX]
                if (node === nonVisitedNode || node === objectiveNode) {
                    result.push([neightbourX, neightbourY]);
                }
            }
        }

        return result;
    };

    const getPath = (gridWidth, gridHeight) => {
        let grid = createGrid(gridWidth, gridHeight);
        
        let objX = getRandomInt(0, gridWidth);
        let startX = getRandomInt(0, gridWidth);
        grid[0][objX] = objectiveNode;
        grid[0][objX-1] = visitedNode;
        grid[0][objX+1] = visitedNode;
        const startY = gridHeight - 1;

        const visited = [[startX, startY]];
        grid[startY][startX-1] = visitedNode;
        grid[startY][startX] = visitedNode;
        grid[startY][startX+1] = visitedNode;

        let x = startX;
        let y = startY;

        while (grid[y][x] !== objectiveNode) {
            const nextPositions = getPossibleNextPositions(x, y, grid);
            if (nextPositions.length == 0) {
                visited.pop();
                const [lastNodeX, lastNodeY] = visited[visited.length - 1];
                x = lastNodeX;
                y = lastNodeY;
                continue;
            }
            const [nextX, nextY] = nextPositions[getRandomInt(0, nextPositions.length)];

            if (grid[nextY][nextX] !== objectiveNode) {
                grid[nextY][nextX] = visitedNode;
            }

            x = nextX;
            y = nextY;
            visited.push([x, y]);
        }

        return visited;
    };

    const draw = (dungeonPiecesMasterData, dungeonPieces, centerX, centerY) => {
        clearBackground();

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "20px serif";

        const msgs = [
            ["Controls:", 3, 23],
            ["a,w,s,d: Move dungeon", 3, 46],
            ["r: Recreate dungeon", 3, 69],
        ];

        for (const [s, x, y] of msgs) {
            ctx.fillText(s, x, y);
        }

        drawDungeonPieces(centerX, centerY, dungeonPieces, dungeonPiecesMasterData);
    };

    const setBlock = (blockMap, block) => {
        if (blockMap[block.y] === undefined) {
            blockMap[block.y] = {}
        }

        blockMap[block.y][block.x] = block;
    };

    const getBlock = (blockMap, x, y) => {
        if (blockMap[y] === undefined) {
            return null;
        }

        if (blockMap[y][x] === undefined) {
            return null;
        }

        return blockMap[y][x];
    };

    const myClone = (obj) => {
        return JSON.parse(JSON.stringify(obj));
    };

    const canChain = (block, toBlock) => {
        if (block.top === 1 && toBlock.bottom === 1) {
            return {x: 0, y: -1};
        } else if (block.bottom === 1 && toBlock.top === 1) {
            return {x: 0, y: 1};
        } else if (block.left === 1 && toBlock.right === 1) {
            return {x: -1, y: 0};
        } else if (block.right === 1 && toBlock.left === 1) {
            return {x: 1, y: 0};
        } else {
            return null;
        }
    }

    const canChainOneOfBlocks = (lastBlock, part) => {
        for (const block of part) {
            let toBlockNewPos = canChain(lastBlock, block);
            if (toBlockNewPos !== null) {
                return toBlockNewPos;
            }
        }
        return null;
    };

    const getRandomInt = (min, max) => {
        const minCeiled = Math.ceil(min);
        const maxFloored = Math.floor(max);
        return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
    };

    const copyAndApplyPos = (part, pos) => {
        let partCopy = myClone(part);
        for (const block of partCopy.blocks) {
            block.x += pos.x;
            block.y += pos.y;
        }
        return partCopy
    };

    const checkBlocksDontClash = (toDungeonPart, blockMap) => {
        for (const toBlock of toDungeonPart.blocks) {
            if (getBlock(blockMap, toBlock.x, toBlock.y) !== null) {
                return false;
            }
        }
        return true;
    };

    const canBeChained = (block, toDungeonPart, blockMap) => {
        let i = 0;

        for (const toBlock of toDungeonPart.blocks) {
            if (block.top == 1 && toBlock.bottom == 1) {
                result = copyAndApplyPos(toDungeonPart, {x: -toBlock.x + block.x, y: -toBlock.y - 1  + block.y});
                result.blocks[i].bottom = 2;
                if (checkBlocksDontClash(result, blockMap)) {
                    return result;
                }
            } 

            if (block.bottom == 1 && toBlock.top == 1) {
                result = copyAndApplyPos(toDungeonPart,  {x: -toBlock.x + block.x, y: -toBlock.y + 1 + block.y});
                result.blocks[i].top = 2;
                if (checkBlocksDontClash(result, blockMap)) {
                    return result;
                }
            } 

            if (block.right == 1 && toBlock.left == 1) {
                result = copyAndApplyPos(toDungeonPart,  {x: -toBlock.x + 1 + block.x, y: -toBlock.y + block.y});
                result.blocks[i].left = 2;
                if (checkBlocksDontClash(result, blockMap)) {
                    return result;
                }
            }

            if (block.left == 1 && toBlock.right == 1) {
                result = copyAndApplyPos(toDungeonPart,  {x: -toBlock.x - 1 + block.x, y: -toBlock.y + block.y});
                result.blocks[i].right = 2;
                if (checkBlocksDontClash(result, blockMap)) {
                    return result;
                }
            }
            i += 1;
        }

        return null;
    };

    const dungeonPartToGame = (dungeonPart) => {
        return {
            "x": dungeonPart.blocks[0].x, "y": dungeonPart.blocks[0].y,
            "rotate": (dungeonPart.angle !== null ? dungeonPart.angle : 0 ),
            "dungeonPieceId": dungeonPart.id
        }
    };

    const getMap = (blockMap, x, y) => {
        if (blockMap[y] !== undefined) {
            if (blockMap[y][x] !== undefined) {
                return blockMap[y][x]
            }
        }

        return null;
    };

    const setMap = (blockMap, x, y, val) => {
        if (blockMap[y] === undefined) {
            blockMap[y] = {}
        }

        blockMap[y][x] = val
    };

    const getNextBlock = (part) => {
        for (const block of part.blocks) {
            if (block.top === 1 || block.bottom === 1 || block.left === 1 || block.right === 1) {
                return block;
            }
        }

        return null;
    };

    const splitDungeonParts = (allDungeonParts) => {
        let startPart = null;
        let endPart = null;
        let middleParts = new Array();

        for (const dungeonPart of allDungeonParts) {
            if (dungeonPart.id == 100101) {
                startPart = dungeonPart;
            } else if (dungeonPart.id == 100201) {
                endPart = dungeonPart;
            } else {
                middleParts.push(dungeonPart);
            }
        }

        return [startPart, middleParts, endPart];
    }

    const equalEntrances = (entrances1, entrances2) => {
        return entrances1.top === entrances2.top
               && entrances1.right === entrances2.right
               && entrances1.bottom === entrances2.bottom
               && entrances1.left === entrances2.left;
    };

    const partCanFit = (i, part, path, middleNodesEntrances) => {
        if (i + part.blocks.length >= path.length) {
            return false;
        }

        let j = 0;
        let lastBlock = null;
        for (const block of part.blocks) {
            const entrances = middleNodesEntrances[i - 1 + j];
            const blockEntrances = {
                top: block.top, right: block.right,
                bottom: block.bottom, left: block.left
            };
            if (!equalEntrances(entrances, blockEntrances)) {
                return false;
            }
            if (lastBlock !== null) {
                const lastNode = path[i + j - 1];
                const node = path[i + j];
                const diffX = node[0] - lastNode[0]
                const diffY = node[1] - lastNode[1];
                if ((block.x - lastBlock.x !== diffX) || (block.y - lastBlock.y !== diffY)) {
                    return false;
                }
            }
            lastBlock = block;
            j += 1;
        }

        return true;
    };

    const updateEntrances = (entrances, node, otherNode) => {
        const [nodeX, nodeY] = node;
        const [otherNodeX, otherNodeY] = otherNode;

        const diffX = nodeX - otherNodeX;
        const diffY = nodeY - otherNodeY;

        if (diffX == 1) {
            entrances.right = 1;
        } else if (diffX == -1) {
            entrances.left = 1;
        }

        if (diffY == 1) {
            entrances.bottom = 1;
        } else if (diffY == -1) {
            entrances.top = 1;
        }
    };

    const getMiddleNodesEntrances = (path) => {
        const middleNodesEntrances = new Array();

        for (let j = 1; j < path.length - 1; ++j) {
            const entrances = {top: 0, right: 0, bottom: 0, left: 0};
            const node = path[j];
            const lastNode = path[j - 1];
            const nextNode = path[j + 1];

            updateEntrances(entrances, lastNode, node);
            updateEntrances(entrances, nextNode, node);

            middleNodesEntrances.push(entrances);
        }

        return middleNodesEntrances;
    };

    const getPossibleParts = (middleParts, i, path, middleNodesEntrances) => {
        const possibleParts = [];
        for (const part of middleParts) {
            if (partCanFit(i, part, path, middleNodesEntrances)) {
                possibleParts.push(part);
            }
        }
        return possibleParts;
    };

    const genDungeon2 = (allDungeonParts) => {
        const [startPart, middleParts, endPart] = splitDungeonParts(allDungeonParts);

        console.log("startPart: ", startPart);
        console.log("endPart: ", endPart);

        const gridWidth = 3;
        const gridHeight = 6;
        const path = getPath(gridWidth, gridHeight);
        console.log("path", path);
        const middleNodesEntrances = getMiddleNodesEntrances(path);
        console.log("middleNodesEntrances", middleNodesEntrances);

        const startNode = path[0];
        const endNode = path[path.length - 1];
        console.log("startNode: ", startNode);
        console.log("endNode: ", endNode);

        const result = new Array();
        result.push(dungeonPartToGame(copyAndApplyPos(startPart, {x: startNode[0], y: startNode[1]})));

        let i = 1;

        while (i < path.length - 1) {
            console.log("i:", i);
            
            const possibleParts = getPossibleParts(middleParts, i, path, middleNodesEntrances);

            if (possibleParts.length === 0) {
                console.log("error: couldn't get a part that fit");
                return result;
            }

            const foundPart = possibleParts[getRandomInt(0, possibleParts.length)];

            console.log("foundPart: ", foundPart);

            const [x, y] = path[i]

            result.push(dungeonPartToGame(copyAndApplyPos(foundPart, {x: x, y: y})))
            
            i += foundPart.blocks.length;
        }

        const [endX, endY] = endNode;
        result.push(dungeonPartToGame(copyAndApplyPos(endPart, {x: endX, y: endY})));
        return result;
    };

    const genDungeon = (allDungeonParts) => {
        let result = new Array();
        let lastBlock = allDungeonParts[0].blocks[0];
        result.push(
            dungeonPartToGame(allDungeonParts[0]),
        );

        const blockMap = {};

        setBlock(blockMap, lastBlock);

        for (let j = 0; j < 8; ++j) {
            let canBeChainedParts = new Array();

            for (const part of allDungeonParts) {
                const newPart = canBeChained(lastBlock, part, blockMap);
                if (newPart !== null) {
                    canBeChainedParts.push(newPart);
                }
            }

            if (canBeChainedParts.length == 0) {
                console.log("canBeChainedParts.length == 0")
                break;
            }

            let i = getRandomInt(0, canBeChainedParts.length);
            let part = canBeChainedParts[i]

            for (const block of part.blocks) {
                setBlock(blockMap, block);
            }

            result.push(dungeonPartToGame(part));

            lastBlock = getNextBlock(part);

            if (lastBlock === null) {
                return result
            }
        }

        console.log(result);

        return result;
    };

    const parseMasterData = (dungeonPiecesMasterData) => {
        const allDungeonParts = new Array();
        for (const dungeonPart of dungeonPiecesMasterData) {
            let asset = splitAssetPath(dungeonPart.asset_path);
            if (asset !== null) {
                let blocks = dungeonParts[asset.name];
                if (asset.angle !== null) {
                    blocks = rotateDungeonPart(blocks, asset.angle)
                }
                allDungeonParts.push({
                    blocks: blocks,
                    id: dungeonPart.id,
                    angle: asset.angle,
                })
            }
        }
        return allDungeonParts;
    }

    const main = async () => {
        const dungeonPiecesMasterData = await getJson("dungeon_piece.json");
        const allDungeonParts = parseMasterData(dungeonPiecesMasterData);
        let dungeonPieces = genDungeon2(allDungeonParts);
        console.log("dungeonPieces: ", dungeonPieces);
        let dungeonPiecesCenterX = 450;
        let dungeonPiecesCenterY = 300;

        draw(dungeonPiecesMasterData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);

        document.body.addEventListener("keyup", (ev) => {
            if (ev.key == "a") {
                dungeonPiecesCenterX -= moveDist
                draw(dungeonPiecesMasterData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            } else if (ev.key == "d") {
                dungeonPiecesCenterX += moveDist
                draw(dungeonPiecesMasterData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            } else if (ev.key == "w") {
                dungeonPiecesCenterY -= moveDist
                draw(dungeonPiecesMasterData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            } else if (ev.key == "s") {
                dungeonPiecesCenterY += moveDist
                draw(dungeonPiecesMasterData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            } else if (ev.key == "r") {
                dungeonPieces = genDungeon2(allDungeonParts);
                draw(dungeonPiecesMasterData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            }
        });
    };

    main();
</script></body></html>