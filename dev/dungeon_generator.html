<!DOCTYPE html>
<html><head><style>
    body {
        margin: 0;
    }
</style></head><body>
<canvas id="canvas" width="1160px" height="580px"></canvas>
<script src="dungeon.js"></script>
<script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const blockSide = 36;
    const margin = 4;
    const dungeonPieceAssetPathPat = /^Adventure\/Dungeon\/Piece\/PartsCity10\/(DungeonParts(?:_2x1)?_[^_]+)(?:_(\d+))?$/;
    const moveDist = 20;

    const clearBackground = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    };

    const drawEntrance = (startx, starty, block) => {
        ctx.strokeStyle = "#FF00FF";

        if (block.top === 1) {
            ctx.beginPath();
            ctx.moveTo(startx, starty);
            ctx.lineTo(startx + blockSide, starty);
            ctx.stroke();
        }

        if (block.right === 1) {
            ctx.beginPath();
            ctx.moveTo(startx + blockSide, starty);
            ctx.lineTo(startx + blockSide, starty + blockSide);
            ctx.stroke();
        }

        if (block.bottom === 1) {
            ctx.beginPath();
            ctx.moveTo(startx, starty + blockSide);
            ctx.lineTo(startx + blockSide, starty + blockSide);
            ctx.stroke();
        }

        if (block.left === 1) {
            ctx.beginPath();
            ctx.moveTo(startx, starty);
            ctx.lineTo(startx, starty + blockSide);
            ctx.stroke();
        }
    }

    const drawDungeonPart = (i, x, y, blocks, backgroundColor) => {
        blocks.forEach((block) => {
            const startx = x + block.x*(blockSide+margin);
            const starty = y + block.y*(blockSide+margin);
            if (backgroundColor === undefined) {
                backgroundColor = "#FFFFFF";
            }
            ctx.strokeStyle = "#FFFFFF";
            ctx.strokeRect(startx, starty, blockSide, blockSide);

            const padding = 2;
            ctx.fillStyle = backgroundColor;
            ctx.font = blockSide.toString() + "px serif"
            const textx = startx + padding;
            const texty = y + block.y*(blockSide+margin) + blockSide - padding;
            ctx.fillText(i.toString(), textx, texty, blockSide);
        });

        blocks.forEach((block) => {
            const startx = x + block.x*(blockSide+margin);
            const starty = y + block.y*(blockSide+margin);
            drawEntrance(startx, starty, block);
        });
    };

    const getJson = async (url) => {
        const res = await fetch(url);
        return res.json();
    };

    const drawDungeonPieces = (x, y, dungeonPieces, dungeonData) => {
        let i = 0;
        for (const dungeonPiece of dungeonPieces) {
            console.log(dungeonPiece.dungeonPieceId)
            const idWithoutCity = dungeonPiece.dungeonPieceId % 10000
            let dungeonPart = getDungeonPartFromId(idWithoutCity, dungeonData);

            if (dungeonPart) {
                const dungeonPieceX = (dungeonPiece.x ? dungeonPiece.x : 0);
                const dungeonPieceY = (dungeonPiece.y ? dungeonPiece.y : 0);
                const dungeonPartX = x + dungeonPieceX*(blockSide + margin);
                const dungeonPartY = y + dungeonPieceY*(blockSide + margin);

                let backgroundColor = "#FFFFFF";
                if (dungeonPart.name == "DungeonParts_Start") {
                    backgroundColor = "#FF0000";
                } else if (dungeonPart.name == "DungeonParts_Boss") {
                    backgroundColor = "#00FF00";
                }

                drawDungeonPart(i, dungeonPartX, dungeonPartY, dungeonPart.blocks, backgroundColor);
            } else {
                console.log("WARNING: " + idWithoutCity + " not found in dungeonParts!!!");
            }

            i += 1;
        }
    }

    const nonVisitedNode = "N";
    const visitedNode = "V";
    const objectiveNode = "O"

    const draw = (dungeonData, dungeonPieces, centerX, centerY) => {
        clearBackground();

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "20px serif";

        const msgs = [
            ["Controls:", 3, 23],
            ["a,w,s,d: Move dungeon", 3, 46],
            ["r: Recreate dungeon", 3, 69],
        ];

        for (const [s, x, y] of msgs) {
            ctx.fillText(s, x, y);
        }

        drawDungeonPieces(centerX, centerY, dungeonPieces, dungeonData);
    };

    const myClone = (obj) => {
        return JSON.parse(JSON.stringify(obj));
    };

    const copyAndApplyPos = (part, pos) => {
        let partCopy = myClone(part);
        for (const block of partCopy.blocks) {
            block.x += pos.x;
            block.y += pos.y;
        }
        return partCopy
    };

    const dungeonPartToGame = (dungeonPart, cityId) => {
        return {
            "x": dungeonPart.blocks[0].x, "y": dungeonPart.blocks[0].y,
            "rotate": (dungeonPart.angle !== null ? dungeonPart.angle : 0 ),
            "dungeonPieceId": cityId*10000 + dungeonPart.id
        };
    };

    const equalEntrances = (entrances1, entrances2) => {
        return entrances1.top === entrances2.top
               && entrances1.right === entrances2.right
               && entrances1.bottom === entrances2.bottom
               && entrances1.left === entrances2.left;
    };

    const partCanFit = (i, part, path, middleNodesEntrances) => {
        if (i + part.blocks.length >= path.length) {
            return false;
        }

        let j = 0;
        let lastBlock = null;
        for (const block of part.blocks) {
            const entrances = middleNodesEntrances[i - 1 + j];
            const blockEntrances = {
                top: block.top, right: block.right,
                bottom: block.bottom, left: block.left
            };
            if (!equalEntrances(entrances, blockEntrances)) {
                return false;
            }
            if (lastBlock !== null) {
                const lastNode = path[i + j - 1];
                const node = path[i + j];
                const diffX = node[0] - lastNode[0]
                const diffY = node[1] - lastNode[1];
                if ((block.x - lastBlock.x !== diffX) || (block.y - lastBlock.y !== diffY)) {
                    return false;
                }
            }
            lastBlock = block;
            j += 1;
        }

        return true;
    };

    const getPossibleParts = (middleParts, i, path, middleNodesEntrances) => {
        const possibleParts = [];
        for (const part of middleParts) {
            if (partCanFit(i, part, path, middleNodesEntrances)) {
                possibleParts.push(part);
            }
        }
        return possibleParts;
    };

    const genDungeon2 = (dungeonData, cityId) => {
        const splittedDungeonParts = splitDungeonParts(dungeonData)
        const startPart = splittedDungeonParts.startPart;
        const middleParts = splittedDungeonParts.middleParts;
        const endPart = splittedDungeonParts.endPart;

        console.log("startPart: ", startPart);
        console.log("endPart: ", endPart);

        const gridWidth = 3;
        const gridHeight = 6;
        const path = getPath(gridWidth, gridHeight);
        console.log("path", path);
        const middleNodesEntrances = getMiddleNodesEntrances(path);
        console.log("middleNodesEntrances", middleNodesEntrances);

        const startNode = path[0];
        const endNode = path[path.length - 1];
        console.log("startNode: ", startNode);
        console.log("endNode: ", endNode);

        const result = new Array();
        result.push(dungeonPartToGame(
            copyAndApplyPos(startPart, {x: startNode[0], y: startNode[1]}),
            cityId
        ));

        let i = 1;

        while (i < path.length - 1) {
            console.log("i:", i);
            
            const possibleParts = getPossibleParts(middleParts, i, path, middleNodesEntrances);

            if (possibleParts.length === 0) {
                console.log("error: couldn't get a part that fit");
                return result;
            }

            const foundPart = possibleParts[getRandomInt(possibleParts.length)];

            console.log("foundPart: ", foundPart);

            const [x, y] = path[i]

            result.push(dungeonPartToGame(
                copyAndApplyPos(foundPart, {x: x, y: y}),
                cityId
            ))

            i += foundPart.blocks.length;
        }

        const [endX, endY] = endNode;
        result.push(dungeonPartToGame(
            copyAndApplyPos(endPart, {x: endX, y: endY}),
            cityId
        ));
        return result;
    };

    const getDungeonPartFromId = (dungeonPieceId, dungeonData) => {
        for (const dungeonPart of dungeonData) {
            if (dungeonPart.id === dungeonPieceId) {
                return dungeonPart;
            }
        }

        return null;
    };

    const main = async () => {
        const dungeonData = await getJson("dungeonData.json");
        const shinagawaId = 10;
        let dungeonPieces = genDungeon2(dungeonData, shinagawaId);
        console.log("dungeonPieces: ", dungeonPieces);
        let dungeonPiecesCenterX = 450;
        let dungeonPiecesCenterY = 300;

        draw(dungeonData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);

        document.body.addEventListener("keyup", (ev) => {
            if (ev.key == "a") {
                dungeonPiecesCenterX -= moveDist
                draw(dungeonData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            } else if (ev.key == "d") {
                dungeonPiecesCenterX += moveDist
                draw(dungeonData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            } else if (ev.key == "w") {
                dungeonPiecesCenterY -= moveDist
                draw(dungeonData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            } else if (ev.key == "s") {
                dungeonPiecesCenterY += moveDist
                draw(dungeonData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            } else if (ev.key == "r") {
                dungeonPieces = genDungeon2(dungeonData, shinagawaId);
                draw(dungeonData, dungeonPieces, dungeonPiecesCenterX, dungeonPiecesCenterY);
            }
        });
    };

    main();
</script></body></html>